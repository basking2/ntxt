<html>
<head>
  <script>
  
  util = { 
    text : {
      eachLine : function( text, f ) {
        var txta = text.split('\n')
        var l
        for ( l in txta ) {
          f(l, txta[l])
        }
      }, // eachLine
    }
  }
  
  ntxt = {
    Exception : function(msg, obj) {
      if ( ! ( this instanceof ntxt.Exception ) ) {
        return new ntxt.Exception(msg, obj)
      }
      this.message = msg
      this.object = obj
    },
    
    BlockParser : function() {
      parser = this
      parser.stack = [] // stack of states to resume parsing
      
      function State(lines, block, lineStart, start, lineEnd) {
        this.lines = lines          // array of lines.
        this.block = block          // context.
        this.lineStart = lineStart  // start of frame.
        this.lineEnd = lineEnd      // end of frame.
        this.line = lineStart       // current line.
        this.start = start          // starting character
        this.offset = 0        // current character offset from start.
        this.currLine = function() { return this.lines[this.line] }
        this.nextLine = function() {
          var nextLine = this.line + 1
          if ( nextLine < this.lineEnd ) {
            var nextOffset = this.offset + this.lines[this.line].length + 1
            this.offset = nextOffset
            this.line = nextLine
            return this.lines[nextLine]
          } else { 
            return null
          }
        }
        this.prevLine = function() {
          var nextLine = this.line - 1
          if ( nextLine >= this.lineStart ) {
            var nextOffset = this.offset - this.lines[nextLine].length - 1
            this.offset = nextOffset
            this.line = nextLine
            return this.lines[nextLine]
          } else { 
            return null
          }
        }
        
        // Shift our starting points to our current points. This
        // effectively consumes text.
        this.consume = function() {
          this.start = this.start + this.offset
          this.offset = 0
          this.lineStart = this.line
        }
        
        // Create a new state that is framed from the lineStart+1 of this state
        // and ends at the current line of the given state.
        this.subState = function() {
          var endOfFrame = this.line+1  
          
          if ( endOfFrame > this.lineEnd ) {
            endOfFrame = this.lineEnd
          }
          
          // function State(lines, block, lineStart, start, lineEnd) {
          var s = new State( this.lines,
                             this.block,
                             this.lineStart+1,
                             this.start+this.lines[this.lineStart].length+1,
                             endOfFrame )
                             
          return s            
        }
        
        // Create a new state that is framed with the remaining contents of 
        // this state.
        this.nextState = function() {
          var s = new State( this.lines,
                             this.block,
                             this.line,
                             this.lineEnd )
          return s
        }
        
        this.toString = function() {
          return  "lineStart: "+this.lineStart+
                  ", lineEnd: " +this.lineEnd+
                  ", line: "+this.line+
                  ", start: "+this.start+
                  ", offset: "+this.offset
        }
      } // State
      
      // Return an array of [ hlevel, and the text in the h level ] or null.
      parser.hlevel = function (line) {
        var m
        if ( ( m = line.match( "^\\s*=([^=].*)=\\s*$") ) ) {
          return [ 1, m[1] ]
        } else if ( ( m = line.match("^\\s*==([^=].*)==\\s*$") ) ) {
          return [ 2, m[1] ]
        } else if ( ( m = line.match("^\\s*===([^=].*)===\\s*$") ) ) {
          return [ 3, m[1] ]
        } else if ( ( m = line.match("^\\s*====([^=].*)====\\s*$") ) ) {
          return [ 4, m[1] ]
        } else if ( ( m = line.match("^\\s*=====([^=].*)=====\\s*$") ) ) {
          return [ 5, m[1] ]
        } else if ( ( m = line.match("^\\s*======([^=].*)======\\s*$") ) ) {
          return [ 6, m[1] ]
        } else {
          return null
        }
      } // hlevel

      // Helper that sets up the parseLines function
      parser.parse = function(ntxtObj) {
      
        if ( !(  ntxtObj instanceof ntxt.Ntxt ) ) {
          ntxtObj = new ntxt.Ntxt(ntxtObj)
        }
        
        var lines = ntxtObj.text.split("\n")
        
        var rootBlock = new ntxt.Block(ntxtObj)
        
        this.stack = [ new State( lines, rootBlock, 0, 0, lines.length ) ]

        this.parseLines()
        
        if ( this.stack.length == 1 ) {
          // parse success!
          return rootBlock
        } else {
          // parse fail!
          return null
        }
      }

      // Consume an entier h-level block and build it.
      parser.parseHlevel = function(level, title) {
        var state = this.stack[this.stack.length-1]
        var line;
        var subState
        var block
        do {
          line = state.nextLine()
          
          if ( line ) {
            var hl = this.hlevel( line )
            if ( hl && parseInt(hl[0]) <= level ) {
              state.prevLine() // rewind
              break;           // we're done.
            }
          }
          
        } while (line!=null);
        
        block = new ntxt.Block(state.block.ntxt, 
                               state.block, 
                               state.start, 
                               state.offset)
        block.title = title
        subState = state.subState()
        subState.block = block
        this.stack.push(subState)
        this.parseLines()
        this.stack.pop()
        state.consume()        
        
      }
      
      parser.parseLines = function() {
        var state = this.stack[this.stack.length-1]
        console.error("Stack001: "+state)
        state.block.children = []

        var tmp
        var line = state.currLine()
        
        while(null != line){
        
          if ( ( tmp = this.hlevel( line ) ) ) {
          
            state.consume()
            parser.parseHlevel(parseInt(tmp[0]), tmp[1])

          } 

          line = state.nextLine()
        }
        
      }
      

    },
  
    // Block constructor
    // ntxtObj the root Ntxt object.
    // parentBlock the parent Block object.
    // startTxt the starting offset in ntxtObj.text where this starts
    // stopTxt the offset in ntxtObje.text after the startTxt position.
    // The block of text submitted must be a valid block, meaning, it may
    // ONLY contain subblocks.
    Block : function(ntxtObj, parentBlock, startTxt, stopTxt) {
    
      // Ensure that this function is only ever called as a constructor.
      if ( ! ( this instanceof ntxt.Block ) ) {
        return new ntxt.Block(ntxtObj)
      }

      // Process sub-blocks if any...
      var block = this
      
      block.children = []         // child blocks.
      block.tags = []             // all tags found in this block and children
      block.start = startTxt || 0
      block.offset = stopTxt || ntxtObj.text.length
      block.ntxt = ntxtObj
      block.parent = parentBlock

      // Set the indent to possibly non-zero if there is a parent block.
      if( block.parent ) {
        // Compute the indent of the first line of this Block.
        var re = /\s*\S/mg
        re.lastIndex = block.start      // set lastIndex
        if( re.test(ntxtObj.text) ) {  // move lastIndex over the whitespace.
          block.indent = re.lastIndex - block.start
        } else {
          block.indent = 0
        }
        block.parent.children.push(this)
      } else {
        block.indent = 0
      }
      
      // Add tags to this block and all parent blocks.
      block.addTag = function(tag) {
        this.tags.push(tag)
        
        if( this.parent ) {
          this.parent.addTag(tag)
        }
      } // addTag
      
      // Call substring on the ntxt array and return the text for this block.
      block.text = function() {
        return this.ntxt.text.substr(this.start, this.offset)
      } // text
      
      block.isRoot = function() { return this.parent }
      
      
    },
  
    // Ntxt Constructor.
    Ntxt : function(txt) {

      if ( ! ( this instanceof ntxt.Ntxt ) ) {
        return new ntxt.Ntxt(txt);
      }
    
      this.text = txt
      
      this.rootBlock = (new ntxt.BlockParser).parse(this)

    }, // Close Ntxt.
    
    // Factory.
    fetchNtxt : function(url) {
      url = url || 'n.txt'
      xmlr = new XMLHttpRequest
      xmlr.open('GET', url, false)
      xmlr.send();
      return new ntxt.Ntxt(xmlr.responseText)
    }
  }

  // debug function. Get rid of.
  function pin(o) { 
    for( i in o ) {
      console.info(i);
    }
  }

  var n=null;

  window.onload = function(){
    n = ntxt.fetchNtxt()
  }
  </script>
</head>
<body>


</body>
</html>
