#!/usr/bin/ruby

require 'rubygems'
require 'optparse'
require 'ntxt'
require 'yaml'

$configs = {
  :cmd => 'last',
  :last => '1',
  :tag_string => '',

  # Replace with command of editor. Otherwise NTXT_EDITOR and EDITOR are used.
  :editor => nil,

  # Tag printing mode describes how tags are printed.
  :tag_print_mode => 'path',
  :filename => "#{ENV['HOME']}/notes.txt"
}

DEFAULT_CONFIG_FILE="#{ENV['HOME']}/.ntxtrc"

# Create or load a configuration file.
if File.exists?(DEFAULT_CONFIG_FILE)
  File.open(DEFAULT_CONFIG_FILE) do |io|
    $configs.merge!(YAML::load(io))
  end
else
  File.open(DEFAULT_CONFIG_FILE, 'w') do |io|
    YAML::dump($configs, io)
  end
end

OptionParser.new do |opt|
  opt.version="1.0.5"

  opt.on('--trace', 'Trace through the file printing summaries.' ) do |v|
    $configs[:cmd] = 'trace'
  end
  
  opt.on('-p','--print', 'Print the whole file one block at a time.' ) do |v|
    $configs[:cmd] = 'print'
  end

  opt.on('-e','--edit', 'Edit using $NTXT_EDITOR or $EDITOR.' ) do |v|
    $configs[:cmd] = 'edit'
  end

  opt.on('-T', '--print_tags', 'Print all tags in the document.') do |v|
    $configs[:cmd] = 'print_tags'
  end
    
  opt.on('-t', '--tag=String', 'Print blocks with tags contaning this.') do |v|
    $configs[:cmd] = 'tag'
    $configs[:tag_string] = v
  end
  
  opt.on('--tm=String', 'Tag printing mode. path, leaf, or parent.') do |v|
    unless v =~ /^(path|leaf|parent)$/
      puts "Tag mode (--tm) must be path, left or parent. Was #{v}."
      exit
    end

    $configs[:tag_print_mode] = v
  end

  opt.on('-l', '--last=[Integer]', 
    'Show the last n top-level blocks.') do |v|
    $configs[:cmd] = 'last'
    $configs[:last] = (v.nil?)? 1 : v.to_i
  end
      
  opt.on('-s','--search=String', 'Search the text for.' ) do |v|
    $configs[:cmd] = 'search'
    $configs[:search_string] = v
  end
end.parse! ARGV

if ARGV.length > 0
  $configs[:filename] = ARGV.shift
end

# Remove empty lines from blocks and print. Guards against nils and empty lines.
def printNonEmpty(txt)
  if txt
    txt = txt.gsub(/^\s*$/m, '')
    print txt, "\n" if txt.length > 0
  end
end

module TagPrintModes
  # Only print the block if the tag count == 0.
  def self.leaf(txt, block, tag)
    if block.tags.member?(tag) and block.tags[tag] == 0
      printNonEmpty(txt)
    end
  end

  # Print the entire parent block if the tag count == 0
  # and the parent tag count == 1. Otherwise, print txt.
  def self.parent(txt, block, tag)
    if block.tags[tag] == 0 and block.parent && block.parent.tags[tag] == 1
      printNonEmpty(block.parent.text)
    else
      printNonEmpty(txt)
    end
  end

  # Print txt always. Effectively this presents a pruned 
  # text path of text that is tagged.
  #
  # This is essentially the Ntxt::Ntxt.walkText algorithm.
  def self.path(txt, block, tag)
    printNonEmpty(txt)
  end
end

$configs[:tag_string] = ARGV.shift if ARGV.length > 0

begin
  ntxt = File.open($configs[:filename]) { |io| Ntxt::Ntxt.new(io.read) }
rescue Errno::ENOENT => e
  puts "The file #{$configs[:filename]} was not found. Exiting."
  exit 1
end

case $configs[:cmd]
when 'print_tags'
  # Notice that we are re-wrapping the tags back into square brackets.
  puts "[#{ntxt.rootBlock.tags.keys.sort.join('] [')}]"
when 'tag'
  ntxt.walkText(
    lambda { |txt, depth, block|
      block.tags.keys.
        # Filter the tags we want.
        select do |x|
          x.index($configs[:tag_string])

        # Process the tags we've selected.
        end.each do |tag|
          TagPrintModes.send($configs[:tag_print_mode], txt, block, tag)
        end
    },
    lambda { |depth, block| },
    lambda { |depth, block| } )
when 'search'
  ntxt.walkText(
    lambda { |txt, depth, block|
      printNonEmpty txt if txt && txt.index( $configs[:search_string])},
    lambda { |depth, block| },
    lambda { |depth, block| } )
when 'print'
  ntxt.walkText(
    lambda { |txt, depth, block| print txt },
    lambda { |depth, block| },
    lambda { |depth, block| } )
when 'last'
  ntxt.rootBlock.children[-$configs[:last].. -1].each do |blk|
    puts blk.text
  end
when 'edit'
  editor = $configs[:editor] || ENV['NTXT_EDITOR'] || ENV['EDITOR']

  if editor.nil?
    puts "No editor defined."
    puts "No editor entry in .ntxtrc."
    puts "No editor entry in NTXT_EDITOR or EDITOR environment variables."
  else
    system("#{editor} \"#{$configs[:filename]}\"")
  end

when 'trace'
  ntxt.walkText(
    lambda { |txt, depth, block| print txt },
    lambda { |depth, block| 
      puts "-----> #{depth} #{block.tags.keys.sort.join(',')}" },
    lambda { |depth, block| 
      puts "<----- #{depth} " } )
when ''
  # nop
when nil
  # nop
else
  puts "Command #{$configs[:cmd]} not found."
end
